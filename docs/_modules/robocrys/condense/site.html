
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>robocrys.condense.site &#8212; Robocrystallographer 0.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
 
<link href='https://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Robocrystallographer 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for robocrys.condense.site</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a class to extract geometry and neighbor information.</span>

<span class="sd">TODO:</span>
<span class="sd">    * distortion of geometry e.g. elongated along an axis</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pymatgen</span> <span class="k">import</span> <span class="n">Composition</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.graphs</span> <span class="k">import</span> <span class="n">StructureGraph</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.periodic_table</span> <span class="k">import</span> <span class="n">get_el_sp</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.coord</span> <span class="k">import</span> <span class="n">get_angle</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.string</span> <span class="k">import</span> <span class="n">formula_double_format</span>

<span class="kn">from</span> <span class="nn">robocrys.condense.fingerprint</span> <span class="k">import</span> <span class="n">get_site_fingerprints</span>
<span class="kn">from</span> <span class="nn">robocrys.util</span> <span class="k">import</span> <span class="n">connected_geometries</span><span class="p">,</span> <span class="n">get_el</span><span class="p">,</span> <span class="n">defaultdict_to_dict</span>


<div class="viewcode-block" id="SiteAnalyzer"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer">[docs]</a><span class="k">class</span> <span class="nc">SiteAnalyzer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to extract information on site geometry and bonding.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        symmetry_labels: A :obj:`dict` mapping the site indices to the symmetry</span>
<span class="sd">            label for that site. If two sites are symmetrically equivalent they</span>
<span class="sd">            share the same symmetry label. The numbering begins at 1 for each</span>
<span class="sd">            element in the structure.</span>
<span class="sd">        equivalent_sites: A :obj:`list` of indices mapping each site in</span>
<span class="sd">            the structure to a symmetrically or structurally equivalent site,</span>
<span class="sd">            depending on the value of ``use_symmetry_equivalent_sites``.</span>

<span class="sd">    Args:</span>
<span class="sd">        bonded_structure: A bonded structure with nearest neighbor data</span>
<span class="sd">            included. For example generated using</span>
<span class="sd">            :class:`pymatgen.analysis.local_env.CrystalNN` or</span>
<span class="sd">            :class:`pymatgen.analysis.local_env.VoronoiNN`.</span>
<span class="sd">        use_symmetry_equivalent_sites: Whether to use symmetry to determine if</span>
<span class="sd">            sites are inequivalent. If ``False``, the site geometry and (next)</span>
<span class="sd">            nearest neighbor information will be used.</span>
<span class="sd">        symprec: The tolerance used when determining the symmetry of</span>
<span class="sd">            the structure. The symmetry can used both to determine if multiple</span>
<span class="sd">            sites are symmetrically equivalent and to obtain the symmetry labels</span>
<span class="sd">            for each site.</span>
<span class="sd">        minimum_geometry_op: The minimum geometrical order parameter for a</span>
<span class="sd">            geometry match to be returned.</span>
<span class="sd">        use_iupac_formula (bool, optional): Whether to order formulas</span>
<span class="sd">            by the iupac &quot;electronegativity&quot; series, defined in</span>
<span class="sd">            Table VI of &quot;Nomenclature of Inorganic Chemistry (IUPAC</span>
<span class="sd">            Recommendations 2005)&quot;. This ordering effectively follows</span>
<span class="sd">            the groups and rows of the periodic table, except the</span>
<span class="sd">            Lanthanides, Actanides and hydrogen. If set to ``False``, the</span>
<span class="sd">            elements will be ordered according to the electronegativity values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">bonded_structure</span><span class="p">:</span> <span class="n">StructureGraph</span><span class="p">,</span>
                 <span class="n">use_symmetry_equivalent_sites</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">symprec</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                 <span class="n">minimum_geometry_op</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
                 <span class="n">use_iupac_formula</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span> <span class="o">=</span> <span class="n">bonded_structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_iupac_formula</span> <span class="o">=</span> <span class="n">use_iupac_formula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_geometry_op</span> <span class="o">=</span> <span class="n">minimum_geometry_op</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">site_fingerprints</span> <span class="o">=</span> <span class="n">get_site_fingerprints</span><span class="p">(</span>
            <span class="n">bonded_structure</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>

        <span class="n">sga</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span>
                                 <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">)</span>
        <span class="n">equivalent_sites</span> <span class="o">=</span> <span class="n">sga</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">()[</span><span class="s1">&#39;equivalent_atoms&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">use_symmetry_equivalent_sites</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">equivalent_sites</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_equivalent_sites</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">symmetry_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_symmetry_labels</span><span class="p">(</span><span class="n">equivalent_sites</span><span class="p">)</span>

<div class="viewcode-block" id="SiteAnalyzer.get_site_geometry"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_site_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">get_site_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_index</span><span class="p">:</span> <span class="nb">int</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Gets the bonding geometry of a site.</span>

<span class="sd">        For example, &quot;octahedral&quot; or &quot;square-planar&quot;.</span>

<span class="sd">        Args:</span>
<span class="sd">            site_index: The site index (zero based).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The site geometry information formatted at as::</span>

<span class="sd">                {&#39;type&#39;: geometry_type, &#39;likeness&#39;: order_parameter}</span>

<span class="sd">            Where ``geometry_type`` is a :obj:`str` corresponding to the</span>
<span class="sd">            geometry type (e.g. octahedral) and ``order_parameter`` is a</span>
<span class="sd">            :obj:`float` indicating whether how close the geometry is to the</span>
<span class="sd">            perfect geometry. If the largest geometrical order parameter falls</span>
<span class="sd">            beneath :attr:`robocrys.site.SiteAnalyzer.minimum_geometry_op`, the</span>
<span class="sd">            geometry type will be returned as &quot;X-coordinate&quot;, where X is the</span>
<span class="sd">            coordination number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get fingerprint as a list of tuples, e.g. [(&quot;op name&quot;, val), ...]</span>
        <span class="n">site_fingerprint</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">site_fingerprints</span><span class="p">[</span><span class="n">site_index</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="c1"># get coordination number with largest weight, ignore op names with</span>
        <span class="c1"># just the coordination number weight (e.g. containing &quot;wt&quot;)</span>
        <span class="n">parameter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">site_fingerprint</span><span class="p">,</span>
                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;wt&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parameter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_geometry_op</span><span class="p">:</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-coordinate&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span>
            <span class="n">likeness</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># return the geometry type without the CN at the end, e.g.</span>
            <span class="c1"># &quot;square co-planar CN_4&quot; -&gt; &quot;square co-planar&quot;</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parameter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="s2">&quot;single-bond&quot;</span> <span class="k">if</span> <span class="n">geometry</span> <span class="o">==</span> <span class="s2">&quot;sgl_bd&quot;</span> <span class="k">else</span> <span class="n">geometry</span>
            <span class="n">likeness</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">geometry</span><span class="p">,</span> <span class="s1">&#39;likeness&#39;</span><span class="p">:</span> <span class="n">likeness</span><span class="p">}</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_nearest_neighbors"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_nearest_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">get_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                              <span class="n">inc_inequivalent_site_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                              <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Gets information about the bonded nearest neighbors.</span>

<span class="sd">        Args:</span>

<span class="sd">            site_index: The site index (zero based).</span>
<span class="sd">            inc_inequivalent_site_index: Whether to include the inequivalent</span>
<span class="sd">                site indices in the nearest neighbor information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            For each site bonded to ``site_index``, returns a :obj:`dict`</span>
<span class="sd">            with the format::</span>

<span class="sd">                {&#39;element&#39;: el, &#39;dist&#39;: distance}</span>

<span class="sd">            If ``inc_inequivalent_site_index=True``, the data will have an</span>
<span class="sd">            additional key ``&#39;inequiv_index&#39;`` corresponding to the inequivalent</span>
<span class="sd">            site index. E.g. if two sites are structurally/symmetrically</span>
<span class="sd">            equivalent (depending on the value of ``self.use_symmetry`` then</span>
<span class="sd">            they will have the same ``inequiv_index``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nn_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">get_connected_sites</span><span class="p">(</span><span class="n">site_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inc_inequivalent_site_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;element&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">),</span>
                     <span class="s1">&#39;inequiv_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">index</span><span class="p">],</span>
                     <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">dist</span><span class="p">}</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">nn_sites</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;element&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">),</span>
                     <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">dist</span><span class="p">}</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">nn_sites</span><span class="p">]</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_next_nearest_neighbors"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_next_nearest_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">get_next_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                   <span class="n">inc_inequivalent_site_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Gets information about the bonded next nearest neighbors.</span>

<span class="sd">        Args:</span>
<span class="sd">            site_index: The site index (zero based).</span>
<span class="sd">            inc_inequivalent_site_index: Whether to include the inequivalent</span>
<span class="sd">                site indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of the next nearest neighbor information. For each next</span>
<span class="sd">            nearest neighbor site, returns a :obj:`dict` with the format::</span>

<span class="sd">                {&#39;element&#39;: el, &#39;connectivity&#39;: con, &#39;geometry&#39;: geom,</span>
<span class="sd">                 &#39;angles&#39;: angles}</span>

<span class="sd">            The ``connectivity`` property is the connectivity type to the</span>
<span class="sd">            next nearest neighbor, e.g. &quot;face&quot;, &quot;corner&quot;, or</span>
<span class="sd">            &quot;edge&quot;. The ``geometry`` property gives the geometry of the</span>
<span class="sd">            next nearest neighbor site. See the ``get_site_geometry`` method for</span>
<span class="sd">            the format of this data. The ``angles`` property gives the bond</span>
<span class="sd">            angles between the site and the next nearest neighbour. Returned as</span>
<span class="sd">            a :obj:`list` of :obj:`int`. Multiple bond angles are given when</span>
<span class="sd">            the two sites share more than nearest neighbor (e.g. if they are</span>
<span class="sd">            face-sharing or edge-sharing).</span>
<span class="sd">            If ``inc_inequivalent_site_index=True``, the data will have an</span>
<span class="sd">            additional key ``&#39;inequiv_index&#39;`` corresponding to the inequivalent</span>
<span class="sd">            site index. E.g. if two sites are structurally/symmetrically</span>
<span class="sd">            equivalent (depending on the value of ``self.use_symmetry`` then</span>
<span class="sd">            they will have the same ``inequiv_index``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_coords</span><span class="p">(</span><span class="n">a_site_index</span><span class="p">,</span> <span class="n">a_site_image</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="n">a_site_index</span><span class="p">]</span> <span class="o">+</span>
                    <span class="n">a_site_image</span><span class="p">))</span>

        <span class="n">nn_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">get_connected_sites</span><span class="p">(</span><span class="n">site_index</span><span class="p">)</span>
        <span class="n">next_nn_sites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">nn_site</span> <span class="ow">in</span> <span class="n">nn_sites</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">get_connected_sites</span><span class="p">(</span>
                             <span class="n">nn_site</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">jimage</span><span class="o">=</span><span class="n">nn_site</span><span class="o">.</span><span class="n">jimage</span><span class="p">)]</span>

        <span class="n">nn_sites_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">site</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">jimage</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">nn_sites</span><span class="p">)</span>

        <span class="n">seen_nnn_sites</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">next_nn_summary</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nnn_site</span> <span class="ow">in</span> <span class="n">next_nn_sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nnn_site</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">site_index</span> <span class="ow">and</span> <span class="n">nnn_site</span><span class="o">.</span><span class="n">jimage</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">nnn_site</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">nnn_site</span><span class="o">.</span><span class="n">jimage</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen_nnn_sites</span><span class="p">):</span>
                <span class="c1"># skip the nnn site if it is the original atom of interest</span>
                <span class="k">continue</span>

            <span class="n">seen_nnn_sites</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">nnn_site</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">nnn_site</span><span class="o">.</span><span class="n">jimage</span><span class="p">))</span>

            <span class="n">sites</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">site</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">jimage</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">get_connected_sites</span><span class="p">(</span>
                            <span class="n">nnn_site</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">jimage</span><span class="o">=</span><span class="n">nnn_site</span><span class="o">.</span><span class="n">jimage</span><span class="p">))</span>
            <span class="n">shared_sites</span> <span class="o">=</span> <span class="n">nn_sites_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
            <span class="n">n_shared_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_sites</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_shared_atoms</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">connectivity</span> <span class="o">=</span> <span class="s1">&#39;corner&#39;</span>
            <span class="k">elif</span> <span class="n">n_shared_atoms</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">connectivity</span> <span class="o">=</span> <span class="s1">&#39;edge&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">connectivity</span> <span class="o">=</span> <span class="s1">&#39;face&#39;</span>

            <span class="n">site_coords</span> <span class="o">=</span> <span class="n">get_coords</span><span class="p">(</span><span class="n">site_index</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">nnn_site_coords</span> <span class="o">=</span> <span class="n">get_coords</span><span class="p">(</span><span class="n">nnn_site</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">nnn_site</span><span class="o">.</span><span class="n">jimage</span><span class="p">)</span>
            <span class="n">nn_site_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_coords</span><span class="p">(</span><span class="n">nn_site_index</span><span class="p">,</span> <span class="n">nn_site_image</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">nn_site_index</span><span class="p">,</span> <span class="n">nn_site_image</span> <span class="ow">in</span> <span class="n">shared_sites</span><span class="p">]</span>

            <span class="c1"># can&#39;t just use Structure.get_angles to calculate angles as it</span>
            <span class="c1"># doesn&#39;t take into account the site image</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_angle</span><span class="p">(</span><span class="n">site_coords</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">nnn_site_coords</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nn_site_coords</span><span class="p">]</span>

            <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_site_geometry</span><span class="p">(</span><span class="n">nnn_site</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

            <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;element&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">nnn_site</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">),</span>
                       <span class="s1">&#39;connectivity&#39;</span><span class="p">:</span> <span class="n">connectivity</span><span class="p">,</span>
                       <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="n">geometry</span><span class="p">,</span>
                       <span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="n">angles</span><span class="p">}</span>

            <span class="k">if</span> <span class="n">inc_inequivalent_site_index</span><span class="p">:</span>
                <span class="n">summary</span><span class="p">[</span><span class="s1">&#39;inequiv_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">[</span><span class="n">nnn_site</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

            <span class="n">next_nn_summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">next_nn_summary</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_site_summary"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_site_summary">[docs]</a>    <span class="k">def</span> <span class="nf">get_site_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Gets a summary of the site information.</span>

<span class="sd">        Args:</span>
<span class="sd">            site_index: The site index (zero based).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A summary of the site information, formatted as::</span>

<span class="sd">                {</span>
<span class="sd">                    &#39;element&#39;: &#39;Mo4+&#39;,</span>
<span class="sd">                    &#39;geometry&#39;: {</span>
<span class="sd">                        &#39;likesness&#39;: 0.5544,</span>
<span class="sd">                        &#39;type&#39;: &#39;pentagonal pyramidal&#39;</span>
<span class="sd">                    },</span>
<span class="sd">                    &#39;nn&#39;: [2, 2, 2, 2, 2, 2],</span>
<span class="sd">                    &#39;nnn&#39;: {&#39;edge&#39;: [0, 0, 0, 0, 0, 0]},</span>
<span class="sd">                    &#39;poly_formula&#39;: &#39;S6&#39;,</span>
<span class="sd">                    &#39;sym_labels&#39;: (1,)</span>
<span class="sd">                }</span>

<span class="sd">            Where ``element`` is the species string (if the species has</span>
<span class="sd">            oxidation states, these will be included in the string). The</span>
<span class="sd">            ``geometry`` key is the geometry information as produced by</span>
<span class="sd">            :meth:`SiteAnalyzer.get_site_geometry`. The `nn` key lists</span>
<span class="sd">            the site indices of the nearest neighbor bonding sites. Note the</span>
<span class="sd">            inequivalent site index is given for each site. The `nnn` key gives</span>
<span class="sd">            the next nearest neighbor information, broken up by the connectivity</span>
<span class="sd">            to that neighbor. The ``poly_formula`` key gives the formula of the</span>
<span class="sd">            bonded nearest neighbors. ``poly_formula`` will be ``None`` if the</span>
<span class="sd">            site geometry is not in :data:`robocrys.util.connected_geometries`.</span>
<span class="sd">            The ``sym_labels`` key gives the symmetry labels of the site. If</span>
<span class="sd">            two sites are symmetrically equivalent they share the same symmetry</span>
<span class="sd">            label. The numbering begins at 1 for each element in the structure.</span>
<span class="sd">            If :attr:`SiteAnalyzer.use_symmetry_inequivalnt_sites` is ``False``,</span>
<span class="sd">            each site may have more than one symmetry label, as structural</span>
<span class="sd">            features have instead been used to determine the site equivalences,</span>
<span class="sd">            i.e. two sites are symmetrically distinct but share the same</span>
<span class="sd">            geometry, nearest neighbor and next nearest neighbor properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">structure</span><span class="p">[</span><span class="n">site_index</span><span class="p">]</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_site_geometry</span><span class="p">(</span><span class="n">site_index</span><span class="p">)</span>

        <span class="n">nn_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nearest_neighbors</span><span class="p">(</span>
            <span class="n">site_index</span><span class="p">,</span> <span class="n">inc_inequivalent_site_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nn_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">nn_site</span><span class="p">[</span><span class="s1">&#39;inequiv_index&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">nn_site</span> <span class="ow">in</span> <span class="n">nn_sites</span><span class="p">]</span>

        <span class="n">nnn_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_nearest_neighbors</span><span class="p">(</span>
            <span class="n">site_index</span><span class="p">,</span> <span class="n">inc_inequivalent_site_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nnn</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nnn_site</span> <span class="ow">in</span> <span class="n">nnn_sites</span><span class="p">:</span>
            <span class="n">nnn</span><span class="p">[</span><span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;connectivity&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;inequiv_index&#39;</span><span class="p">])</span>
        <span class="n">nnn</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">nnn</span><span class="p">)</span>

        <span class="n">equiv_sites</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">))</span>
                       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">[</span>
                           <span class="n">site_index</span><span class="p">]]</span>
        <span class="n">sym_labels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetry_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">equiv_sites</span><span class="p">]))</span>

        <span class="n">poly_formula</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_poly_formula</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">nn_sites</span><span class="p">,</span> <span class="n">nnn_sites</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;element&#39;</span><span class="p">:</span> <span class="n">element</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="n">geometry</span><span class="p">,</span> <span class="s1">&#39;nn&#39;</span><span class="p">:</span> <span class="n">nn_indices</span><span class="p">,</span>
                <span class="s1">&#39;nnn&#39;</span><span class="p">:</span> <span class="n">nnn</span><span class="p">,</span> <span class="s1">&#39;poly_formula&#39;</span><span class="p">:</span> <span class="n">poly_formula</span><span class="p">,</span>
                <span class="s1">&#39;sym_labels&#39;</span><span class="p">:</span> <span class="n">sym_labels</span><span class="p">}</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_bond_distance_summary"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_bond_distance_summary">[docs]</a>    <span class="k">def</span> <span class="nf">get_bond_distance_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_index</span><span class="p">:</span> <span class="nb">int</span>
                                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Gets the bond distance summary for a site.</span>

<span class="sd">        Args:</span>
<span class="sd">            site_index: The site index (zero based).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The bonding data for the site, formatted as::</span>

<span class="sd">                {to_site: [dist_1, dist_2, dist_3, ...]}</span>

<span class="sd">            Where ``to_site`` is the index of a nearest neighbor site</span>
<span class="sd">            and ``dist_1`` etc are the bond distances as :obj:`float`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nn_site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nearest_neighbors</span><span class="p">(</span><span class="n">site_index</span><span class="p">):</span>
            <span class="n">to_site</span> <span class="o">=</span> <span class="n">nn_site</span><span class="p">[</span><span class="s1">&#39;inequiv_index&#39;</span><span class="p">]</span>
            <span class="n">bonds</span><span class="p">[</span><span class="n">to_site</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn_site</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">defaultdict_to_dict</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_connectivity_angle_summary"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_connectivity_angle_summary">[docs]</a>    <span class="k">def</span> <span class="nf">get_connectivity_angle_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_index</span><span class="p">:</span> <span class="nb">int</span>
                                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Gets the connectivity angle summary for a site.</span>

<span class="sd">        The connectivity angles are the angles between a site and its</span>
<span class="sd">        next nearest neighbors.</span>

<span class="sd">        Args:</span>
<span class="sd">            site_index: The site index (zero based).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The connectivity angle data for the site, formatted as::</span>

<span class="sd">                {</span>
<span class="sd">                    to_site: {</span>
<span class="sd">                        connectivity_a: [angle_1, angle_2, ...]</span>
<span class="sd">                        connectivity_b: [angle_1, angle_2, ...]</span>
<span class="sd">                    }</span>
<span class="sd">                }</span>

<span class="sd">            Where ``to_site`` is the index of a next nearest neighbor site,</span>
<span class="sd">            ``connectivity_a`` etc are the bonding connectivity type, e.g.</span>
<span class="sd">            ``&#39;edge&#39;`` or ``&#39;corner&#39;`` (for edge-sharing and corner-sharing</span>
<span class="sd">            connectivity), and ``angle_1`` etc are the bond angles as</span>
<span class="sd">            :obj:`float`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">connectivities</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">nnn_site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_nearest_neighbors</span><span class="p">(</span>
                <span class="n">site_index</span><span class="p">,</span> <span class="n">inc_inequivalent_site_index</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">to_site</span> <span class="o">=</span> <span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;inequiv_index&#39;</span><span class="p">]</span>
            <span class="n">connectivity</span> <span class="o">=</span> <span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;connectivity&#39;</span><span class="p">]</span>
            <span class="n">connectivities</span><span class="p">[</span><span class="n">to_site</span><span class="p">][</span><span class="n">connectivity</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">defaultdict_to_dict</span><span class="p">(</span><span class="n">connectivities</span><span class="p">)</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_all_site_summaries"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_all_site_summaries">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_site_summaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the site summaries for all sites.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The site summaries for all sites, formatted as::</span>

<span class="sd">                {</span>
<span class="sd">                    site_index: site_summary</span>
<span class="sd">                }</span>

<span class="sd">            Where ``site_summary`` has the same format as produced by</span>
<span class="sd">            :meth:`SiteAnalyzer.get_site_summary`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">site</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_site_summary</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">)}</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_all_bond_distance_summaries"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_all_bond_distance_summaries">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_bond_distance_summaries</span><span class="p">(</span><span class="bp">self</span>
                                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Gets the bond distance summaries for all sites.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The bond distance summaries for all sites, formatted as::</span>

<span class="sd">                {</span>
<span class="sd">                    from_site: {</span>
<span class="sd">                        to_site: distances</span>
<span class="sd">                    }</span>
<span class="sd">                }</span>

<span class="sd">            Where ``from_site`` and ``to_site`` are site indices and</span>
<span class="sd">            ``distances`` is a :obj:`list` of :obj:`float` of bond distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">from_site</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bond_distance_summary</span><span class="p">(</span><span class="n">from_site</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">from_site</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">)}</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_all_connectivity_angle_summaries"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_all_connectivity_angle_summaries">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_connectivity_angle_summaries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span>
            <span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]]:</span>
        <span class="sd">&quot;&quot;&quot;Gets the connectivity angle summaries for all sites.</span>

<span class="sd">        The connectivity angles are the angles between a site and its</span>
<span class="sd">        next nearest neighbors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The connectivity angle summaries for all sites, formatted as::</span>

<span class="sd">                {</span>
<span class="sd">                    from_site: {</span>
<span class="sd">                        to_site: {</span>
<span class="sd">                            connectivity: angles</span>
<span class="sd">                        }</span>
<span class="sd">                    }</span>
<span class="sd">                }</span>

<span class="sd">            Where ``from_site`` and ``to_site`` are the site indices of</span>
<span class="sd">            two sites, ``connectivity`` is the connectivity type (e.g.</span>
<span class="sd">            ``&#39;edge&#39;`` or ``&#39;face&#39;``) and ``angles`` is a :obj:`list` of</span>
<span class="sd">            :obj:`float` of connectivity angles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">from_site</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connectivity_angle_summary</span><span class="p">(</span><span class="n">from_site</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">from_site</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">)}</span></div>

<div class="viewcode-block" id="SiteAnalyzer.get_inequivalent_site_indices"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.SiteAnalyzer.get_inequivalent_site_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_inequivalent_site_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
                                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Gets the inequivalent site indices from a list of site indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            site_indices: The site indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The inequivalent site indices. For example, if a structure has 4</span>
<span class="sd">            sites where the first two are equivalent and the last two are</span>
<span class="sd">            inequivalent. If  ``site_indices=[0, 1, 2, 3]`` the output will be::</span>

<span class="sd">                [0, 2, 3]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">site_indices</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_calculate_equivalent_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">likeness_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                                    <span class="n">bond_dist_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                                    <span class="n">bond_angle_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span>
                                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Determines the indices of the structurally inequivalent sites.</span>

<span class="sd">        Args:</span>
<span class="sd">            likeness_tol: The tolerance used to determine if two likeness</span>
<span class="sd">                parameters are the same.</span>
<span class="sd">            bond_dist_tol: The tolerance used to determine if two bond lengths</span>
<span class="sd">                are the same.</span>
<span class="sd">            bond_angle_tol: The tolerance used to determine if two bond angles</span>
<span class="sd">                are the same.</span>

<span class="sd">        Two sites are considered equivalent if they are the same element, and</span>
<span class="sd">        have the same geometry and (next) nearest neighbors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A :obj:`list` of indices mapping each site in the structure to a</span>
<span class="sd">            structurally equivalent site. For example, if the first two sites</span>
<span class="sd">            are equivalent and the last two are both inequivalent, the data will</span>
<span class="sd">            be formatted as::</span>

<span class="sd">                [0, 0, 2, 3]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Use site fingerprint rather than geometry type.</span>
        <span class="n">inequiv_sites</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">equivalent_sites</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">site_index</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">structure</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">get_el_sp</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_site_geometry</span><span class="p">(</span><span class="n">site_index</span><span class="p">)</span>
            <span class="n">nn_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nearest_neighbors</span><span class="p">(</span>
                <span class="n">site_index</span><span class="p">,</span> <span class="n">inc_inequivalent_site_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">nnn_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_nearest_neighbors</span><span class="p">(</span>
                <span class="n">site_index</span><span class="p">,</span> <span class="n">inc_inequivalent_site_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">matched</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">inequiv_index</span><span class="p">,</span> <span class="n">inequiv_site</span> <span class="ow">in</span> <span class="n">inequiv_sites</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">elem_match</span> <span class="o">=</span> <span class="n">element</span> <span class="o">==</span> <span class="n">inequiv_site</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">]</span>
                <span class="n">geom_match</span> <span class="o">=</span> <span class="n">geometries_match</span><span class="p">(</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">inequiv_site</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span>
                    <span class="n">likeness_tol</span><span class="o">=</span><span class="n">likeness_tol</span><span class="p">)</span>
                <span class="n">nn_match</span> <span class="o">=</span> <span class="n">nn_summaries_match</span><span class="p">(</span>
                    <span class="n">nn_sites</span><span class="p">,</span> <span class="n">inequiv_site</span><span class="p">[</span><span class="s1">&#39;nn_sites&#39;</span><span class="p">],</span>
                    <span class="n">bond_dist_tol</span><span class="o">=</span><span class="n">bond_dist_tol</span><span class="p">)</span>
                <span class="n">nnn_match</span> <span class="o">=</span> <span class="n">nnn_summaries_match</span><span class="p">(</span>
                    <span class="n">nnn_sites</span><span class="p">,</span> <span class="n">inequiv_site</span><span class="p">[</span><span class="s1">&#39;nnn_sites&#39;</span><span class="p">],</span>
                    <span class="n">bond_angle_tol</span><span class="o">=</span><span class="n">bond_angle_tol</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">elem_match</span> <span class="ow">and</span> <span class="n">geom_match</span> <span class="ow">and</span> <span class="n">nn_match</span> <span class="ow">and</span> <span class="n">nnn_match</span><span class="p">:</span>
                    <span class="n">equivalent_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inequiv_index</span><span class="p">)</span>
                    <span class="n">matched</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
                <span class="c1"># no matches therefore store original site index</span>
                <span class="n">equivalent_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site_index</span><span class="p">)</span>
                <span class="n">site_data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;element&#39;</span><span class="p">:</span> <span class="n">element</span><span class="p">,</span>
                             <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="n">geometry</span><span class="p">,</span>
                             <span class="s1">&#39;nn_sites&#39;</span><span class="p">:</span> <span class="n">nn_sites</span><span class="p">,</span>
                             <span class="s1">&#39;nnn_sites&#39;</span><span class="p">:</span> <span class="n">nnn_sites</span><span class="p">}</span>
                <span class="n">inequiv_sites</span><span class="p">[</span><span class="n">site_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">site_data</span>

        <span class="k">return</span> <span class="n">equivalent_sites</span>

    <span class="k">def</span> <span class="nf">_calculate_symmetry_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sym_equivalent_atoms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
                                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Calculates the symmetry labels for all sites in the structure.</span>

<span class="sd">        The symmetry labels number the sites in the structure. If two sites</span>
<span class="sd">        are symmetrically equivalent they share the same symmetry label. The</span>
<span class="sd">        numbering begins at 1 for each element in the structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            sym_equivalent_atoms: A :obj:`list` of indices mapping each site in</span>
<span class="sd">                the structure to a symmetrically equivalent site. The data</span>
<span class="sd">                should be formatted as given by the ``equivalent_atoms`` key in</span>
<span class="sd">                :meth`SpacegroupAnalyzer.get_symmetry_dataset()`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A mapping between the site index and symmetry label for that site.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symmetry_labels</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># this way is a little long winded but works if the sites aren&#39;t</span>
        <span class="c1"># grouped together by element</span>
        <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">species</span><span class="p">:</span>
            <span class="n">el_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonded_structure</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">indices_from_symbol</span><span class="p">(</span>
                <span class="n">get_el</span><span class="p">(</span><span class="n">specie</span><span class="p">))</span>
            <span class="n">equiv_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym_equivalent_atoms</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">el_indices</span><span class="p">]</span>

            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">equiv_index_to_sym_label</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">el_index</span><span class="p">,</span> <span class="n">equiv_index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">el_indices</span><span class="p">,</span> <span class="n">equiv_indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">equiv_index</span> <span class="ow">in</span> <span class="n">equiv_index_to_sym_label</span><span class="p">:</span>
                    <span class="n">symmetry_labels</span><span class="p">[</span><span class="n">el_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">equiv_index_to_sym_label</span><span class="p">[</span>
                        <span class="n">equiv_index</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">equiv_index_to_sym_label</span><span class="p">[</span><span class="n">equiv_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                    <span class="n">symmetry_labels</span><span class="p">[</span><span class="n">el_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">symmetry_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">symmetry_labels</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>

    <span class="k">def</span> <span class="nf">_get_poly_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">geometry</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
                          <span class="n">nn_sites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                          <span class="n">nnn_sites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Gets the polyhedra formula of the nearest neighbor atoms.</span>

<span class="sd">        The polyhedral formula is effectively the sorted nearest neighbor</span>
<span class="sd">        atoms in a reduced format. For example, if the nearest neighbors are</span>
<span class="sd">        3 I atoms, 2 Br atoms and 1 Cl atom, the polyhedral formula will be</span>
<span class="sd">        &quot;I3Br2Cl&quot;. The polyhedral formula will be ``None`` if the site geometry</span>
<span class="sd">        is not in :data:`robocrys.util.connected_geometries`.</span>

<span class="sd">        Args:</span>
<span class="sd">            geometry: The site geometry as produced by</span>
<span class="sd">                :meth:`SiteAnalyzer.get_site_geometry`.</span>
<span class="sd">            nn_sites: The nearest neighbor sites as produced by</span>
<span class="sd">                :meth:`SiteAnalyzer.get_nearest_neighbors`.</span>
<span class="sd">            nnn_sites: The next nearest neighbor sites as produced by</span>
<span class="sd">                :meth:`SiteAnalyzer.get_next_nearest_neighbors`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The polyhedral formula if the site geometry is in</span>
<span class="sd">            :data:`robocrys.util.connected_geometries` else ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">order_elements</span><span class="p">(</span><span class="n">el</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_iupac_formula</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">get_el_sp</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">el</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">get_el_sp</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">.</span><span class="n">iupac_ordering</span><span class="p">,</span> <span class="n">el</span><span class="p">]</span>

        <span class="n">nnn_geometries</span> <span class="o">=</span> <span class="p">[</span><span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">nnn_site</span> <span class="ow">in</span> <span class="n">nnn_sites</span><span class="p">]</span>

        <span class="n">poly_formula</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">connected_geometries</span> <span class="ow">and</span>
                <span class="nb">any</span><span class="p">([</span><span class="n">nnn_geometry</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">connected_geometries</span>
                     <span class="k">for</span> <span class="n">nnn_geometry</span> <span class="ow">in</span> <span class="n">nnn_geometries</span><span class="p">])):</span>
            <span class="n">nn_els</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_el</span><span class="p">(</span><span class="n">nn_site</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">nn_site</span> <span class="ow">in</span> <span class="n">nn_sites</span><span class="p">]</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nn_els</span><span class="p">))</span>
            <span class="n">el_amt_dict</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">get_el_amt_dict</span><span class="p">()</span>

            <span class="n">poly_formula</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">el_amt_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">order_elements</span><span class="p">):</span>
                <span class="n">poly_formula</span> <span class="o">+=</span> <span class="n">e</span>
                <span class="n">poly_formula</span> <span class="o">+=</span> <span class="n">formula_double_format</span><span class="p">(</span><span class="n">el_amt_dict</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">poly_formula</span></div>


<div class="viewcode-block" id="geometries_match"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.geometries_match">[docs]</a><span class="k">def</span> <span class="nf">geometries_match</span><span class="p">(</span><span class="n">geometry_a</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
                     <span class="n">geometry_b</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
                     <span class="n">likeness_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Determine whether two site geometries match.</span>

<span class="sd">    Geometry data should be formatted the same as produced by</span>
<span class="sd">    :meth:`robocrys.site.SiteAnalyzer.get_site_geometry`.</span>

<span class="sd">    Args:</span>
<span class="sd">        geometry_a: The first set of geometry data.</span>
<span class="sd">        geometry_b: The second set of geometry data.</span>
<span class="sd">        likeness_tol: The tolerance used to determine if two likeness parameters</span>
<span class="sd">            are the same.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Whether the two geometries are the same.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">geometry_a</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">geometry_b</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="ow">and</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">geometry_a</span><span class="p">[</span><span class="s1">&#39;likeness&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">geometry_b</span><span class="p">[</span><span class="s1">&#39;likeness&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">likeness_tol</span><span class="p">)</span></div>


<div class="viewcode-block" id="nn_summaries_match"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.nn_summaries_match">[docs]</a><span class="k">def</span> <span class="nf">nn_summaries_match</span><span class="p">(</span><span class="n">nn_sites_a</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span>
                       <span class="n">nn_sites_b</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span>
                       <span class="n">bond_dist_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                       <span class="n">match_bond_dists</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Determine whether two sets of nearest neighbors match.</span>

<span class="sd">    Nearest neighbor data should be formatted the same as produced by</span>
<span class="sd">    :meth:`robocrys.site.SiteAnalyzer.get_nearest_neighbors`.</span>

<span class="sd">    Args:</span>
<span class="sd">        nn_sites_a: The first set of nearest neighbors.</span>
<span class="sd">        nn_sites_b: The second set of nearest neighbors.</span>
<span class="sd">        bond_dist_tol: The tolerance used to determine if two bond lengths</span>
<span class="sd">            are the same.</span>
<span class="sd">        match_bond_dists: Whether to consider bond distances when matching.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Whether the two sets of nearest neighbors match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">nn_sites_order</span><span class="p">(</span><span class="n">nn_site</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">nn_site</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">],</span> <span class="n">nn_site</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_sites_a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_sites_b</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">nn_sites_a</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nn_sites_a</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">nn_sites_order</span><span class="p">)</span>
    <span class="n">nn_sites_b</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nn_sites_b</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">nn_sites_order</span><span class="p">)</span>

    <span class="n">dists_match</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">site_a</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">site_b</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">bond_dist_tol</span>
                   <span class="k">if</span> <span class="n">match_bond_dists</span> <span class="k">else</span> <span class="kc">True</span>
                   <span class="k">for</span> <span class="n">site_a</span><span class="p">,</span> <span class="n">site_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nn_sites_a</span><span class="p">,</span> <span class="n">nn_sites_b</span><span class="p">)]</span>
    <span class="n">elements_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">site_a</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">site_b</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">site_a</span><span class="p">,</span> <span class="n">site_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nn_sites_a</span><span class="p">,</span> <span class="n">nn_sites_b</span><span class="p">)]</span>

    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">d</span> <span class="ow">and</span> <span class="n">e</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dists_match</span><span class="p">,</span> <span class="n">elements_match</span><span class="p">))</span></div>


<div class="viewcode-block" id="nnn_summaries_match"><a class="viewcode-back" href="../../../robocrys.condense.html#robocrys.condense.site.nnn_summaries_match">[docs]</a><span class="k">def</span> <span class="nf">nnn_summaries_match</span><span class="p">(</span><span class="n">nnn_sites_a</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                        <span class="n">nnn_sites_b</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                        <span class="n">likeness_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                        <span class="n">bond_angle_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                        <span class="n">match_bond_angles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether two sets of next nearest neighbors match.</span>

<span class="sd">    Next nearest neighbor data should be formatted the same as produced by</span>
<span class="sd">    :meth:`robocrys.site.SiteAnalyzer.get_next_nearest_neighbors`.</span>

<span class="sd">    Args:</span>
<span class="sd">        nnn_sites_a: The first set of next nearest neighbors.</span>
<span class="sd">        nnn_sites_b: The second set of next nearest neighbors.</span>
<span class="sd">        likeness_tol: The tolerance used to determine if two likeness parameters</span>
<span class="sd">            are the same.</span>
<span class="sd">        bond_angle_tol: The tolerance used to determine if two bond angles</span>
<span class="sd">            are the same.</span>
<span class="sd">        match_bond_angles: Whether to consider bond angles when matching.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Whether the two sets of next nearest neighbors match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">nnn_sites_order</span><span class="p">(</span><span class="n">nnn_site</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">],</span> <span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">],</span>
                <span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;connectivity&#39;</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nnn_site</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">])]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nnn_sites_a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nnn_sites_b</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">nnn_sites_a</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nnn_sites_a</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">nnn_sites_order</span><span class="p">)</span>
    <span class="n">nnn_sites_b</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nnn_sites_b</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">nnn_sites_order</span><span class="p">)</span>

    <span class="n">elements_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">site_a</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">site_b</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">site_a</span><span class="p">,</span> <span class="n">site_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nnn_sites_a</span><span class="p">,</span> <span class="n">nnn_sites_b</span><span class="p">)]</span>
    <span class="n">cons_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">site_a</span><span class="p">[</span><span class="s1">&#39;connectivity&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">site_b</span><span class="p">[</span><span class="s1">&#39;connectivity&#39;</span><span class="p">]</span>
                  <span class="k">for</span> <span class="n">site_a</span><span class="p">,</span> <span class="n">site_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nnn_sites_a</span><span class="p">,</span> <span class="n">nnn_sites_b</span><span class="p">)]</span>
    <span class="n">geoms_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">geometries_match</span><span class="p">(</span><span class="n">site_a</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span> <span class="n">site_b</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span>
                                    <span class="n">likeness_tol</span><span class="o">=</span><span class="n">likeness_tol</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">site_a</span><span class="p">,</span> <span class="n">site_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nnn_sites_a</span><span class="p">,</span> <span class="n">nnn_sites_b</span><span class="p">)]</span>
    <span class="n">angles_match</span> <span class="o">=</span> <span class="p">[</span><span class="nb">all</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">a_a</span> <span class="o">-</span> <span class="n">a_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bond_angle_tol</span> <span class="k">for</span> <span class="n">a_a</span><span class="p">,</span> <span class="n">a_b</span> <span class="ow">in</span>
                         <span class="nb">zip</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">site_a</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]),</span>
                             <span class="nb">sorted</span><span class="p">(</span><span class="n">site_b</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]))])</span>
                    <span class="k">if</span> <span class="n">match_bond_angles</span> <span class="k">else</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">site_a</span><span class="p">,</span> <span class="n">site_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nnn_sites_a</span><span class="p">,</span> <span class="n">nnn_sites_b</span><span class="p">)]</span>

    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">g</span> <span class="ow">and</span> <span class="n">a</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span>
               <span class="nb">zip</span><span class="p">(</span><span class="n">elements_match</span><span class="p">,</span> <span class="n">cons_match</span><span class="p">,</span> <span class="n">geoms_match</span><span class="p">,</span> <span class="n">angles_match</span><span class="p">))</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Robocrystallographer 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Alex Ganose.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>